require("dotenv").config();
const pg = require("pg");
const bcrypt = require("bcrypt");
const SALT_ROUNDS = 10;

const pool = new pg.Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT,
  ssl: {
    rejectUnauthorized: false,
  },
});

const createTables = async () => {
  const query = `
        CREATE TABLE IF NOT EXISTS "users" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "username" VARCHAR(100) NOT NULL,
        "password" VARCHAR(100) NOT NULL,
        "email" VARCHAR(60) NOT NULL
        );

        CREATE TABLE IF NOT EXISTS "user_roles" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "user_id" INT NOT NULL,
        "role_id" INT NOT NULL
        );

        CREATE TABLE IF NOT EXISTS "roles" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "name" VARCHAR(60) NOT NULL
        );

        CREATE TABLE IF NOT EXISTS "appointments" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "appointment_date" TIMESTAMP NOT NULL,
        "user_id" INT NOT NULL,
        "title" VARCHAR(70) NOT NULL,
        "description" TEXT NOT NULL,
        "is_approved" VARCHAR(50) DEFAULT 'PENDING',
        "admin_review" TEXT
        );

        CREATE TABLE IF NOT EXISTS "appointment_files" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "appointment_id" INT NOT NULL,
        "file_path" VARCHAR(255) NOT NULL
        );

        CREATE TABLE IF NOT EXISTS "supplies" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "name" VARCHAR(100) NOT NULL,
        "description" TEXT,
        "in_stock" INT NOT NULL
        );

        CREATE TABLE IF NOT EXISTS "orders" (
        "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        "supply_id" INTEGER NOT NULL,
        "provider" VARCHAR(100) NOT NULL,
        "description" text
        );
    `;
  await pool.query(query);
};

const alterTables = async () => {
  const constraints = [
    `ALTER TABLE appointment_files ADD CONSTRAINT fk_appointment_id FOREIGN KEY (appointment_id) REFERENCES appointments(id);`,
    `ALTER TABLE orders ADD CONSTRAINT fk_supply_id FOREIGN KEY (supply_id) REFERENCES supplies(id);`,
    `ALTER TABLE user_roles ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id);`,
    `ALTER TABLE user_roles ADD CONSTRAINT fk_role_id FOREIGN KEY (role_id) REFERENCES roles(id);`,
    `ALTER TABLE appointments ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES users(id);`,
    `ALTER TABLE users ADD CONSTRAINT unique_email UNIQUE (email);`,
  ];

  for (const c of constraints) {
    const safeQuery = `
          DO $$
          BEGIN
            BEGIN
              ${c}
            EXCEPTION WHEN duplicate_object OR duplicate_table THEN
              RAISE NOTICE 'Constraint already exists: skipping.';
            END;
          END
          $$;
        `;
    await pool.query(safeQuery);
  }
};

const insertRoles = async () => {
  const roles = ["client", "admin"];
  for (const role of roles) {
    try {
      await pool.query(
        "INSERT INTO roles (name) SELECT CAST($1 AS varchar) WHERE NOT EXISTS (SELECT 1 FROM roles WHERE name = $1)",
        [role]
      );
    } catch (err) {
      console.error("error inserting roles: ", err);
    }
  }
};

const createOriginalAdmin = async () => {
  let query = `
              INSERT INTO users(username, password, email)
              VALUES ($1, $2, $3)
              ON CONFLICT(email) DO NOTHING
              RETURNING id;
              `;
  const hashedAdminPass = await bcrypt.hash(
    process.env.ADMIN_PASS,
    SALT_ROUNDS
  );
  let values = ["TheOriginalAdmin", hashedAdminPass, "dummy@gmail.com"];
  const result = await pool.query(query, values);
  if (result.rows.length > 0 && result.rows[0].id) {
    const adminId = result.rows[0].id;

    query = `
          INSERT INTO user_roles(user_id, role_id) values($1, 2);
          `;
    values = [adminId];
    await pool.query(query, values);
  }
};

const setupDatabase = async () => {
  try {
    await createTables();
    await alterTables();
    await insertRoles();
    await createOriginalAdmin();
    console.log("database setup complete.");
  } catch (error) {
    console.error("error setting up the database:", error);
  }
};

module.exports = {
  pool,
  setupDatabase,
};
